def GraphChallenge(strArr):
    # Extracting the number of nodes
    num_nodes = int(strArr[0])
    
    # Mapping nodes to their index in the strArr
    node_indices = {node: index for index, node in enumerate(strArr[1:num_nodes + 1])}
    
    # Creating an adjacency list to represent the graph
    graph = {node: [] for node in strArr[1:num_nodes + 1]}
    
    # Parsing connections and weights
    for connection in strArr[num_nodes + 1:]:
        start, end, weight = connection.split('|')
        graph[start].append((end, int(weight)))
        graph[end].append((start, int(weight)))  # Since A-B implies B-A as well
    
    # Dijkstra's algorithm to find shortest path
    start_node = strArr[1]
    end_node = strArr[num_nodes]
    
    # Dictionary to store the shortest distance to each node
    shortest_distance = {node: float('inf') for node in graph}
    shortest_distance[start_node] = 0
    # Dictionary to store the previous node in the shortest path
    previous_node = {node: None for node in graph}
    # Set to keep track of visited nodes
    visited = set()
    
    while True:
        # Find the unvisited node with the smallest distance
        min_distance = float('inf')
        min_node = None
        for node in graph:
            if node not in visited and shortest_distance[node] < min_distance:
                min_distance = shortest_distance[node]
                min_node = node
        
        if min_node is None:
            break  # No more nodes to explore
        
        visited.add(min_node)
        
        if min_node == end_node:
            # Reconstruct the path from end to start
            path = []
            current_node = end_node
            while current_node is not None:
                path.append(current_node)
                current_node = previous_node[current_node]
            # Reverse the path to get it from start to end
            return '-'.join(path[::-1])
        
        for neighbor, weight in graph[min_node]:
            distance = shortest_distance[min_node] + weight
            if distance < shortest_distance[neighbor]:
                shortest_distance[neighbor] = distance
                previous_node[neighbor] = min_node
    
    return -1  # No path exists

# Test cases
print(GraphChallenge(["4","A","B","C","D","A|B|1","B|D|9","B|C|3","C|D|4"]))  # Output: A-B-C-D
print(GraphChallenge(["7","A","B","C","D","E","F","G","A|B|1","A|E|9","B|C|2","C|D|1","D|F|2","E|D|6","F|G|2"]))  # Output: A-B-C-D-F-G
